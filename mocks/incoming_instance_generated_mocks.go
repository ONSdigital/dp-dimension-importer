// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/ONSdigital/dp-dimension-importer/event"
	"github.com/ONSdigital/dp-dimension-importer/model"
	"sync"
)

var (
	lockDatasetAPIClientMockGetDimensions      sync.RWMutex
	lockDatasetAPIClientMockGetInstance        sync.RWMutex
	lockDatasetAPIClientMockPutDimensionNodeID sync.RWMutex
)

// DatasetAPIClientMock is a mock implementation of DatasetAPIClient.
//
//     func TestSomethingThatUsesDatasetAPIClient(t *testing.T) {
//
//         // make and configure a mocked DatasetAPIClient
//         mockedDatasetAPIClient := &DatasetAPIClientMock{
//             GetDimensionsFunc: func(instanceID string) ([]*model.Dimension, error) {
// 	               panic("TODO: mock out the GetDimensions method")
//             },
//             GetInstanceFunc: func(instanceID string) (*model.Instance, error) {
// 	               panic("TODO: mock out the GetInstance method")
//             },
//             PutDimensionNodeIDFunc: func(instanceID string, dimension *model.Dimension) error {
// 	               panic("TODO: mock out the PutDimensionNodeID method")
//             },
//         }
//
//         // TODO: use mockedDatasetAPIClient in code that requires DatasetAPIClient
//         //       and then make assertions.
//
//     }
type DatasetAPIClientMock struct {
	// GetDimensionsFunc mocks the GetDimensions method.
	GetDimensionsFunc func(instanceID string) ([]*model.Dimension, error)

	// GetInstanceFunc mocks the GetInstance method.
	GetInstanceFunc func(instanceID string) (*model.Instance, error)

	// PutDimensionNodeIDFunc mocks the PutDimensionNodeID method.
	PutDimensionNodeIDFunc func(instanceID string, dimension *model.Dimension) error

	// calls tracks calls to the methods.
	calls struct {
		// GetDimensions holds details about calls to the GetDimensions method.
		GetDimensions []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// GetInstance holds details about calls to the GetInstance method.
		GetInstance []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// PutDimensionNodeID holds details about calls to the PutDimensionNodeID method.
		PutDimensionNodeID []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension *model.Dimension
		}
	}
}

// GetDimensions calls GetDimensionsFunc.
func (mock *DatasetAPIClientMock) GetDimensions(instanceID string) ([]*model.Dimension, error) {
	if mock.GetDimensionsFunc == nil {
		panic("DatasetAPIClientMock.GetDimensionsFunc: method is nil but DatasetAPIClient.GetDimensions was just called")
	}
	callInfo := struct {
		InstanceID string
	}{
		InstanceID: instanceID,
	}
	lockDatasetAPIClientMockGetDimensions.Lock()
	mock.calls.GetDimensions = append(mock.calls.GetDimensions, callInfo)
	lockDatasetAPIClientMockGetDimensions.Unlock()
	return mock.GetDimensionsFunc(instanceID)
}

// GetDimensionsCalls gets all the calls that were made to GetDimensions.
// Check the length with:
//     len(mockedDatasetAPIClient.GetDimensionsCalls())
func (mock *DatasetAPIClientMock) GetDimensionsCalls() []struct {
	InstanceID string
} {
	var calls []struct {
		InstanceID string
	}
	lockDatasetAPIClientMockGetDimensions.RLock()
	calls = mock.calls.GetDimensions
	lockDatasetAPIClientMockGetDimensions.RUnlock()
	return calls
}

// GetInstance calls GetInstanceFunc.
func (mock *DatasetAPIClientMock) GetInstance(instanceID string) (*model.Instance, error) {
	if mock.GetInstanceFunc == nil {
		panic("DatasetAPIClientMock.GetInstanceFunc: method is nil but DatasetAPIClient.GetInstance was just called")
	}
	callInfo := struct {
		InstanceID string
	}{
		InstanceID: instanceID,
	}
	lockDatasetAPIClientMockGetInstance.Lock()
	mock.calls.GetInstance = append(mock.calls.GetInstance, callInfo)
	lockDatasetAPIClientMockGetInstance.Unlock()
	return mock.GetInstanceFunc(instanceID)
}

// GetInstanceCalls gets all the calls that were made to GetInstance.
// Check the length with:
//     len(mockedDatasetAPIClient.GetInstanceCalls())
func (mock *DatasetAPIClientMock) GetInstanceCalls() []struct {
	InstanceID string
} {
	var calls []struct {
		InstanceID string
	}
	lockDatasetAPIClientMockGetInstance.RLock()
	calls = mock.calls.GetInstance
	lockDatasetAPIClientMockGetInstance.RUnlock()
	return calls
}

// PutDimensionNodeID calls PutDimensionNodeIDFunc.
func (mock *DatasetAPIClientMock) PutDimensionNodeID(instanceID string, dimension *model.Dimension) error {
	if mock.PutDimensionNodeIDFunc == nil {
		panic("DatasetAPIClientMock.PutDimensionNodeIDFunc: method is nil but DatasetAPIClient.PutDimensionNodeID was just called")
	}
	callInfo := struct {
		InstanceID string
		Dimension  *model.Dimension
	}{
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	lockDatasetAPIClientMockPutDimensionNodeID.Lock()
	mock.calls.PutDimensionNodeID = append(mock.calls.PutDimensionNodeID, callInfo)
	lockDatasetAPIClientMockPutDimensionNodeID.Unlock()
	return mock.PutDimensionNodeIDFunc(instanceID, dimension)
}

// PutDimensionNodeIDCalls gets all the calls that were made to PutDimensionNodeID.
// Check the length with:
//     len(mockedDatasetAPIClient.PutDimensionNodeIDCalls())
func (mock *DatasetAPIClientMock) PutDimensionNodeIDCalls() []struct {
	InstanceID string
	Dimension  *model.Dimension
} {
	var calls []struct {
		InstanceID string
		Dimension  *model.Dimension
	}
	lockDatasetAPIClientMockPutDimensionNodeID.RLock()
	calls = mock.calls.PutDimensionNodeID
	lockDatasetAPIClientMockPutDimensionNodeID.RUnlock()
	return calls
}

var (
	lockInstanceRepositoryMockAddDimensions          sync.RWMutex
	lockInstanceRepositoryMockClose                  sync.RWMutex
	lockInstanceRepositoryMockCreate                 sync.RWMutex
	lockInstanceRepositoryMockCreateCodeRelationship sync.RWMutex
	lockInstanceRepositoryMockExists                 sync.RWMutex
)

// InstanceRepositoryMock is a mock implementation of InstanceRepository.
//
//     func TestSomethingThatUsesInstanceRepository(t *testing.T) {
//
//         // make and configure a mocked InstanceRepository
//         mockedInstanceRepository := &InstanceRepositoryMock{
//             AddDimensionsFunc: func(instance *model.Instance) error {
// 	               panic("TODO: mock out the AddDimensions method")
//             },
//             CloseFunc: func()  {
// 	               panic("TODO: mock out the Close method")
//             },
//             CreateFunc: func(instance *model.Instance) error {
// 	               panic("TODO: mock out the Create method")
//             },
//             CreateCodeRelationshipFunc: func(i *model.Instance, code string) error {
// 	               panic("TODO: mock out the CreateCodeRelationship method")
//             },
//             ExistsFunc: func(instance *model.Instance) (bool, error) {
// 	               panic("TODO: mock out the Exists method")
//             },
//         }
//
//         // TODO: use mockedInstanceRepository in code that requires InstanceRepository
//         //       and then make assertions.
//
//     }
type InstanceRepositoryMock struct {
	// AddDimensionsFunc mocks the AddDimensions method.
	AddDimensionsFunc func(instance *model.Instance) error

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CreateFunc mocks the Create method.
	CreateFunc func(instance *model.Instance) error

	// CreateCodeRelationshipFunc mocks the CreateCodeRelationship method.
	CreateCodeRelationshipFunc func(i *model.Instance, code string) error

	// ExistsFunc mocks the Exists method.
	ExistsFunc func(instance *model.Instance) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddDimensions holds details about calls to the AddDimensions method.
		AddDimensions []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
		}
		// CreateCodeRelationship holds details about calls to the CreateCodeRelationship method.
		CreateCodeRelationship []struct {
			// I is the i argument value.
			I *model.Instance
			// Code is the code argument value.
			Code string
		}
		// Exists holds details about calls to the Exists method.
		Exists []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
		}
	}
}

// AddDimensions calls AddDimensionsFunc.
func (mock *InstanceRepositoryMock) AddDimensions(instance *model.Instance) error {
	if mock.AddDimensionsFunc == nil {
		panic("InstanceRepositoryMock.AddDimensionsFunc: method is nil but InstanceRepository.AddDimensions was just called")
	}
	callInfo := struct {
		Instance *model.Instance
	}{
		Instance: instance,
	}
	lockInstanceRepositoryMockAddDimensions.Lock()
	mock.calls.AddDimensions = append(mock.calls.AddDimensions, callInfo)
	lockInstanceRepositoryMockAddDimensions.Unlock()
	return mock.AddDimensionsFunc(instance)
}

// AddDimensionsCalls gets all the calls that were made to AddDimensions.
// Check the length with:
//     len(mockedInstanceRepository.AddDimensionsCalls())
func (mock *InstanceRepositoryMock) AddDimensionsCalls() []struct {
	Instance *model.Instance
} {
	var calls []struct {
		Instance *model.Instance
	}
	lockInstanceRepositoryMockAddDimensions.RLock()
	calls = mock.calls.AddDimensions
	lockInstanceRepositoryMockAddDimensions.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *InstanceRepositoryMock) Close() {
	if mock.CloseFunc == nil {
		panic("InstanceRepositoryMock.CloseFunc: method is nil but InstanceRepository.Close was just called")
	}
	callInfo := struct {
	}{}
	lockInstanceRepositoryMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockInstanceRepositoryMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedInstanceRepository.CloseCalls())
func (mock *InstanceRepositoryMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockInstanceRepositoryMockClose.RLock()
	calls = mock.calls.Close
	lockInstanceRepositoryMockClose.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *InstanceRepositoryMock) Create(instance *model.Instance) error {
	if mock.CreateFunc == nil {
		panic("InstanceRepositoryMock.CreateFunc: method is nil but InstanceRepository.Create was just called")
	}
	callInfo := struct {
		Instance *model.Instance
	}{
		Instance: instance,
	}
	lockInstanceRepositoryMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockInstanceRepositoryMockCreate.Unlock()
	return mock.CreateFunc(instance)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedInstanceRepository.CreateCalls())
func (mock *InstanceRepositoryMock) CreateCalls() []struct {
	Instance *model.Instance
} {
	var calls []struct {
		Instance *model.Instance
	}
	lockInstanceRepositoryMockCreate.RLock()
	calls = mock.calls.Create
	lockInstanceRepositoryMockCreate.RUnlock()
	return calls
}

// CreateCodeRelationship calls CreateCodeRelationshipFunc.
func (mock *InstanceRepositoryMock) CreateCodeRelationship(i *model.Instance, code string) error {
	if mock.CreateCodeRelationshipFunc == nil {
		panic("InstanceRepositoryMock.CreateCodeRelationshipFunc: method is nil but InstanceRepository.CreateCodeRelationship was just called")
	}
	callInfo := struct {
		I    *model.Instance
		Code string
	}{
		I:    i,
		Code: code,
	}
	lockInstanceRepositoryMockCreateCodeRelationship.Lock()
	mock.calls.CreateCodeRelationship = append(mock.calls.CreateCodeRelationship, callInfo)
	lockInstanceRepositoryMockCreateCodeRelationship.Unlock()
	return mock.CreateCodeRelationshipFunc(i, code)
}

// CreateCodeRelationshipCalls gets all the calls that were made to CreateCodeRelationship.
// Check the length with:
//     len(mockedInstanceRepository.CreateCodeRelationshipCalls())
func (mock *InstanceRepositoryMock) CreateCodeRelationshipCalls() []struct {
	I    *model.Instance
	Code string
} {
	var calls []struct {
		I    *model.Instance
		Code string
	}
	lockInstanceRepositoryMockCreateCodeRelationship.RLock()
	calls = mock.calls.CreateCodeRelationship
	lockInstanceRepositoryMockCreateCodeRelationship.RUnlock()
	return calls
}

// Exists calls ExistsFunc.
func (mock *InstanceRepositoryMock) Exists(instance *model.Instance) (bool, error) {
	if mock.ExistsFunc == nil {
		panic("InstanceRepositoryMock.ExistsFunc: method is nil but InstanceRepository.Exists was just called")
	}
	callInfo := struct {
		Instance *model.Instance
	}{
		Instance: instance,
	}
	lockInstanceRepositoryMockExists.Lock()
	mock.calls.Exists = append(mock.calls.Exists, callInfo)
	lockInstanceRepositoryMockExists.Unlock()
	return mock.ExistsFunc(instance)
}

// ExistsCalls gets all the calls that were made to Exists.
// Check the length with:
//     len(mockedInstanceRepository.ExistsCalls())
func (mock *InstanceRepositoryMock) ExistsCalls() []struct {
	Instance *model.Instance
} {
	var calls []struct {
		Instance *model.Instance
	}
	lockInstanceRepositoryMockExists.RLock()
	calls = mock.calls.Exists
	lockInstanceRepositoryMockExists.RUnlock()
	return calls
}

var (
	lockDimensionRepositoryMockClose  sync.RWMutex
	lockDimensionRepositoryMockInsert sync.RWMutex
)

// DimensionRepositoryMock is a mock implementation of DimensionRepository.
//
//     func TestSomethingThatUsesDimensionRepository(t *testing.T) {
//
//         // make and configure a mocked DimensionRepository
//         mockedDimensionRepository := &DimensionRepositoryMock{
//             CloseFunc: func()  {
// 	               panic("TODO: mock out the Close method")
//             },
//             InsertFunc: func(instance *model.Instance, dimension *model.Dimension) (*model.Dimension, error) {
// 	               panic("TODO: mock out the Insert method")
//             },
//         }
//
//         // TODO: use mockedDimensionRepository in code that requires DimensionRepository
//         //       and then make assertions.
//
//     }
type DimensionRepositoryMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// InsertFunc mocks the Insert method.
	InsertFunc func(instance *model.Instance, dimension *model.Dimension) (*model.Dimension, error)

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
			// Dimension is the dimension argument value.
			Dimension *model.Dimension
		}
	}
}

// Close calls CloseFunc.
func (mock *DimensionRepositoryMock) Close() {
	if mock.CloseFunc == nil {
		panic("DimensionRepositoryMock.CloseFunc: method is nil but DimensionRepository.Close was just called")
	}
	callInfo := struct {
	}{}
	lockDimensionRepositoryMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockDimensionRepositoryMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedDimensionRepository.CloseCalls())
func (mock *DimensionRepositoryMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockDimensionRepositoryMockClose.RLock()
	calls = mock.calls.Close
	lockDimensionRepositoryMockClose.RUnlock()
	return calls
}

// Insert calls InsertFunc.
func (mock *DimensionRepositoryMock) Insert(instance *model.Instance, dimension *model.Dimension) (*model.Dimension, error) {
	if mock.InsertFunc == nil {
		panic("DimensionRepositoryMock.InsertFunc: method is nil but DimensionRepository.Insert was just called")
	}
	callInfo := struct {
		Instance  *model.Instance
		Dimension *model.Dimension
	}{
		Instance:  instance,
		Dimension: dimension,
	}
	lockDimensionRepositoryMockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	lockDimensionRepositoryMockInsert.Unlock()
	return mock.InsertFunc(instance, dimension)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//     len(mockedDimensionRepository.InsertCalls())
func (mock *DimensionRepositoryMock) InsertCalls() []struct {
	Instance  *model.Instance
	Dimension *model.Dimension
} {
	var calls []struct {
		Instance  *model.Instance
		Dimension *model.Dimension
	}
	lockDimensionRepositoryMockInsert.RLock()
	calls = mock.calls.Insert
	lockDimensionRepositoryMockInsert.RUnlock()
	return calls
}

var (
	lockObservationRepositoryMockClose            sync.RWMutex
	lockObservationRepositoryMockCreateConstraint sync.RWMutex
)

// ObservationRepositoryMock is a mock implementation of ObservationRepository.
//
//     func TestSomethingThatUsesObservationRepository(t *testing.T) {
//
//         // make and configure a mocked ObservationRepository
//         mockedObservationRepository := &ObservationRepositoryMock{
//             CloseFunc: func()  {
// 	               panic("TODO: mock out the Close method")
//             },
//             CreateConstraintFunc: func(instance *model.Instance) error {
// 	               panic("TODO: mock out the CreateConstraint method")
//             },
//         }
//
//         // TODO: use mockedObservationRepository in code that requires ObservationRepository
//         //       and then make assertions.
//
//     }
type ObservationRepositoryMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CreateConstraintFunc mocks the CreateConstraint method.
	CreateConstraintFunc func(instance *model.Instance) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// CreateConstraint holds details about calls to the CreateConstraint method.
		CreateConstraint []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
		}
	}
}

// Close calls CloseFunc.
func (mock *ObservationRepositoryMock) Close() {
	if mock.CloseFunc == nil {
		panic("ObservationRepositoryMock.CloseFunc: method is nil but ObservationRepository.Close was just called")
	}
	callInfo := struct {
	}{}
	lockObservationRepositoryMockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	lockObservationRepositoryMockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//     len(mockedObservationRepository.CloseCalls())
func (mock *ObservationRepositoryMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	lockObservationRepositoryMockClose.RLock()
	calls = mock.calls.Close
	lockObservationRepositoryMockClose.RUnlock()
	return calls
}

// CreateConstraint calls CreateConstraintFunc.
func (mock *ObservationRepositoryMock) CreateConstraint(instance *model.Instance) error {
	if mock.CreateConstraintFunc == nil {
		panic("ObservationRepositoryMock.CreateConstraintFunc: method is nil but ObservationRepository.CreateConstraint was just called")
	}
	callInfo := struct {
		Instance *model.Instance
	}{
		Instance: instance,
	}
	lockObservationRepositoryMockCreateConstraint.Lock()
	mock.calls.CreateConstraint = append(mock.calls.CreateConstraint, callInfo)
	lockObservationRepositoryMockCreateConstraint.Unlock()
	return mock.CreateConstraintFunc(instance)
}

// CreateConstraintCalls gets all the calls that were made to CreateConstraint.
// Check the length with:
//     len(mockedObservationRepository.CreateConstraintCalls())
func (mock *ObservationRepositoryMock) CreateConstraintCalls() []struct {
	Instance *model.Instance
} {
	var calls []struct {
		Instance *model.Instance
	}
	lockObservationRepositoryMockCreateConstraint.RLock()
	calls = mock.calls.CreateConstraint
	lockObservationRepositoryMockCreateConstraint.RUnlock()
	return calls
}

var (
	lockCompletedProducerMockCompleted sync.RWMutex
)

// CompletedProducerMock is a mock implementation of CompletedProducer.
//
//     func TestSomethingThatUsesCompletedProducer(t *testing.T) {
//
//         // make and configure a mocked CompletedProducer
//         mockedCompletedProducer := &CompletedProducerMock{
//             CompletedFunc: func(e event.InstanceCompleted) error {
// 	               panic("TODO: mock out the Completed method")
//             },
//         }
//
//         // TODO: use mockedCompletedProducer in code that requires CompletedProducer
//         //       and then make assertions.
//
//     }
type CompletedProducerMock struct {
	// CompletedFunc mocks the Completed method.
	CompletedFunc func(e event.InstanceCompleted) error

	// calls tracks calls to the methods.
	calls struct {
		// Completed holds details about calls to the Completed method.
		Completed []struct {
			// E is the e argument value.
			E event.InstanceCompleted
		}
	}
}

// Completed calls CompletedFunc.
func (mock *CompletedProducerMock) Completed(e event.InstanceCompleted) error {
	if mock.CompletedFunc == nil {
		panic("CompletedProducerMock.CompletedFunc: method is nil but CompletedProducer.Completed was just called")
	}
	callInfo := struct {
		E event.InstanceCompleted
	}{
		E: e,
	}
	lockCompletedProducerMockCompleted.Lock()
	mock.calls.Completed = append(mock.calls.Completed, callInfo)
	lockCompletedProducerMockCompleted.Unlock()
	return mock.CompletedFunc(e)
}

// CompletedCalls gets all the calls that were made to Completed.
// Check the length with:
//     len(mockedCompletedProducer.CompletedCalls())
func (mock *CompletedProducerMock) CompletedCalls() []struct {
	E event.InstanceCompleted
} {
	var calls []struct {
		E event.InstanceCompleted
	}
	lockCompletedProducerMockCompleted.RLock()
	calls = mock.calls.Completed
	lockCompletedProducerMockCompleted.RUnlock()
	return calls
}
