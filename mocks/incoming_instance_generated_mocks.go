// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/ONSdigital/dp-dimension-importer/event"
	"github.com/ONSdigital/dp-dimension-importer/handler"
	"sync"
)

var (
	lockCompletedProducerMockCompleted sync.RWMutex
)

// Ensure, that CompletedProducerMock does implement handler.CompletedProducer.
// If this is not the case, regenerate this file with moq.
var _ handler.CompletedProducer = &CompletedProducerMock{}

// CompletedProducerMock is a mock implementation of handler.CompletedProducer.
//
//     func TestSomethingThatUsesCompletedProducer(t *testing.T) {
//
//         // make and configure a mocked handler.CompletedProducer
//         mockedCompletedProducer := &CompletedProducerMock{
//             CompletedFunc: func(ctx context.Context, e event.InstanceCompleted) error {
// 	               panic("mock out the Completed method")
//             },
//         }
//
//         // use mockedCompletedProducer in code that requires handler.CompletedProducer
//         // and then make assertions.
//
//     }
type CompletedProducerMock struct {
	// CompletedFunc mocks the Completed method.
	CompletedFunc func(ctx context.Context, e event.InstanceCompleted) error

	// calls tracks calls to the methods.
	calls struct {
		// Completed holds details about calls to the Completed method.
		Completed []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// E is the e argument value.
			E event.InstanceCompleted
		}
	}
}

// Completed calls CompletedFunc.
func (mock *CompletedProducerMock) Completed(ctx context.Context, e event.InstanceCompleted) error {
	if mock.CompletedFunc == nil {
		panic("CompletedProducerMock.CompletedFunc: method is nil but CompletedProducer.Completed was just called")
	}
	callInfo := struct {
		Ctx context.Context
		E   event.InstanceCompleted
	}{
		Ctx: ctx,
		E:   e,
	}
	lockCompletedProducerMockCompleted.Lock()
	mock.calls.Completed = append(mock.calls.Completed, callInfo)
	lockCompletedProducerMockCompleted.Unlock()
	return mock.CompletedFunc(ctx, e)
}

// CompletedCalls gets all the calls that were made to Completed.
// Check the length with:
//     len(mockedCompletedProducer.CompletedCalls())
func (mock *CompletedProducerMock) CompletedCalls() []struct {
	Ctx context.Context
	E   event.InstanceCompleted
} {
	var calls []struct {
		Ctx context.Context
		E   event.InstanceCompleted
	}
	lockCompletedProducerMockCompleted.RLock()
	calls = mock.calls.Completed
	lockCompletedProducerMockCompleted.RUnlock()
	return calls
}
