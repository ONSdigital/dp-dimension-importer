// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package handler

import (
	"github.com/ONSdigital/dp-dimension-importer/model"
	"sync"
)

var (
	lockImportAPIClientMockGetDimensions      sync.RWMutex
	lockImportAPIClientMockPutDimensionNodeID sync.RWMutex
)

// ImportAPIClientMock is a mock implementation of ImportAPIClient.
//
//     func TestSomethingThatUsesImportAPIClient(t *testing.T) {
//
//         // make and configure a mocked ImportAPIClient
//         mockedImportAPIClient := &ImportAPIClientMock{
//             GetDimensionsFunc: func(instanceID string) ([]*model.Dimension, error) {
// 	               panic("TODO: mock out the GetDimensions method")
//             },
//             PutDimensionNodeIDFunc: func(instanceID string, dimension *model.Dimension) error {
// 	               panic("TODO: mock out the PutDimensionNodeID method")
//             },
//         }
//
//         // TODO: use mockedImportAPIClient in code that requires ImportAPIClient
//         //       and then make assertions.
//
//     }
type ImportAPIClientMock struct {
	// GetDimensionsFunc mocks the GetDimensions method.
	GetDimensionsFunc func(instanceID string) ([]*model.Dimension, error)

	// PutDimensionNodeIDFunc mocks the PutDimensionNodeID method.
	PutDimensionNodeIDFunc func(instanceID string, dimension *model.Dimension) error

	// calls tracks calls to the methods.
	calls struct {
		// GetDimensions holds details about calls to the GetDimensions method.
		GetDimensions []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
		}
		// PutDimensionNodeID holds details about calls to the PutDimensionNodeID method.
		PutDimensionNodeID []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Dimension is the dimension argument value.
			Dimension *model.Dimension
		}
	}
}

// GetDimensions calls GetDimensionsFunc.
func (mock *ImportAPIClientMock) GetDimensions(instanceID string) ([]*model.Dimension, error) {
	if mock.GetDimensionsFunc == nil {
		panic("moq: ImportAPIClientMock.GetDimensionsFunc is nil but ImportAPIClient.GetDimensions was just called")
	}
	callInfo := struct {
		InstanceID string
	}{
		InstanceID: instanceID,
	}
	lockImportAPIClientMockGetDimensions.Lock()
	mock.calls.GetDimensions = append(mock.calls.GetDimensions, callInfo)
	lockImportAPIClientMockGetDimensions.Unlock()
	return mock.GetDimensionsFunc(instanceID)
}

// GetDimensionsCalls gets all the calls that were made to GetDimensions.
// Check the length with:
//     len(mockedImportAPIClient.GetDimensionsCalls())
func (mock *ImportAPIClientMock) GetDimensionsCalls() []struct {
	InstanceID string
} {
	var calls []struct {
		InstanceID string
	}
	lockImportAPIClientMockGetDimensions.RLock()
	calls = mock.calls.GetDimensions
	lockImportAPIClientMockGetDimensions.RUnlock()
	return calls
}

// PutDimensionNodeID calls PutDimensionNodeIDFunc.
func (mock *ImportAPIClientMock) PutDimensionNodeID(instanceID string, dimension *model.Dimension) error {
	if mock.PutDimensionNodeIDFunc == nil {
		panic("moq: ImportAPIClientMock.PutDimensionNodeIDFunc is nil but ImportAPIClient.PutDimensionNodeID was just called")
	}
	callInfo := struct {
		InstanceID string
		Dimension  *model.Dimension
	}{
		InstanceID: instanceID,
		Dimension:  dimension,
	}
	lockImportAPIClientMockPutDimensionNodeID.Lock()
	mock.calls.PutDimensionNodeID = append(mock.calls.PutDimensionNodeID, callInfo)
	lockImportAPIClientMockPutDimensionNodeID.Unlock()
	return mock.PutDimensionNodeIDFunc(instanceID, dimension)
}

// PutDimensionNodeIDCalls gets all the calls that were made to PutDimensionNodeID.
// Check the length with:
//     len(mockedImportAPIClient.PutDimensionNodeIDCalls())
func (mock *ImportAPIClientMock) PutDimensionNodeIDCalls() []struct {
	InstanceID string
	Dimension  *model.Dimension
} {
	var calls []struct {
		InstanceID string
		Dimension  *model.Dimension
	}
	lockImportAPIClientMockPutDimensionNodeID.RLock()
	calls = mock.calls.PutDimensionNodeID
	lockImportAPIClientMockPutDimensionNodeID.RUnlock()
	return calls
}

var (
	lockInstanceRepositoryMockAddDimensions sync.RWMutex
	lockInstanceRepositoryMockCreate        sync.RWMutex
)

// InstanceRepositoryMock is a mock implementation of InstanceRepository.
//
//     func TestSomethingThatUsesInstanceRepository(t *testing.T) {
//
//         // make and configure a mocked InstanceRepository
//         mockedInstanceRepository := &InstanceRepositoryMock{
//             AddDimensionsFunc: func(instance *model.Instance) error {
// 	               panic("TODO: mock out the AddDimensions method")
//             },
//             CreateFunc: func(instance *model.Instance) error {
// 	               panic("TODO: mock out the Create method")
//             },
//         }
//
//         // TODO: use mockedInstanceRepository in code that requires InstanceRepository
//         //       and then make assertions.
//
//     }
type InstanceRepositoryMock struct {
	// AddDimensionsFunc mocks the AddDimensions method.
	AddDimensionsFunc func(instance *model.Instance) error

	// CreateFunc mocks the Create method.
	CreateFunc func(instance *model.Instance) error

	// calls tracks calls to the methods.
	calls struct {
		// AddDimensions holds details about calls to the AddDimensions method.
		AddDimensions []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
		}
		// Create holds details about calls to the Create method.
		Create []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
		}
	}
}

// AddDimensions calls AddDimensionsFunc.
func (mock *InstanceRepositoryMock) AddDimensions(instance *model.Instance) error {
	if mock.AddDimensionsFunc == nil {
		panic("moq: InstanceRepositoryMock.AddDimensionsFunc is nil but InstanceRepository.AddDimensions was just called")
	}
	callInfo := struct {
		Instance *model.Instance
	}{
		Instance: instance,
	}
	lockInstanceRepositoryMockAddDimensions.Lock()
	mock.calls.AddDimensions = append(mock.calls.AddDimensions, callInfo)
	lockInstanceRepositoryMockAddDimensions.Unlock()
	return mock.AddDimensionsFunc(instance)
}

// AddDimensionsCalls gets all the calls that were made to AddDimensions.
// Check the length with:
//     len(mockedInstanceRepository.AddDimensionsCalls())
func (mock *InstanceRepositoryMock) AddDimensionsCalls() []struct {
	Instance *model.Instance
} {
	var calls []struct {
		Instance *model.Instance
	}
	lockInstanceRepositoryMockAddDimensions.RLock()
	calls = mock.calls.AddDimensions
	lockInstanceRepositoryMockAddDimensions.RUnlock()
	return calls
}

// Create calls CreateFunc.
func (mock *InstanceRepositoryMock) Create(instance *model.Instance) error {
	if mock.CreateFunc == nil {
		panic("moq: InstanceRepositoryMock.CreateFunc is nil but InstanceRepository.Create was just called")
	}
	callInfo := struct {
		Instance *model.Instance
	}{
		Instance: instance,
	}
	lockInstanceRepositoryMockCreate.Lock()
	mock.calls.Create = append(mock.calls.Create, callInfo)
	lockInstanceRepositoryMockCreate.Unlock()
	return mock.CreateFunc(instance)
}

// CreateCalls gets all the calls that were made to Create.
// Check the length with:
//     len(mockedInstanceRepository.CreateCalls())
func (mock *InstanceRepositoryMock) CreateCalls() []struct {
	Instance *model.Instance
} {
	var calls []struct {
		Instance *model.Instance
	}
	lockInstanceRepositoryMockCreate.RLock()
	calls = mock.calls.Create
	lockInstanceRepositoryMockCreate.RUnlock()
	return calls
}

var (
	lockDimensionRepositoryMockInsert sync.RWMutex
)

// DimensionRepositoryMock is a mock implementation of DimensionRepository.
//
//     func TestSomethingThatUsesDimensionRepository(t *testing.T) {
//
//         // make and configure a mocked DimensionRepository
//         mockedDimensionRepository := &DimensionRepositoryMock{
//             InsertFunc: func(instance *model.Instance, dimension *model.Dimension) (*model.Dimension, error) {
// 	               panic("TODO: mock out the Insert method")
//             },
//         }
//
//         // TODO: use mockedDimensionRepository in code that requires DimensionRepository
//         //       and then make assertions.
//
//     }
type DimensionRepositoryMock struct {
	// InsertFunc mocks the Insert method.
	InsertFunc func(instance *model.Instance, dimension *model.Dimension) (*model.Dimension, error)

	// calls tracks calls to the methods.
	calls struct {
		// Insert holds details about calls to the Insert method.
		Insert []struct {
			// Instance is the instance argument value.
			Instance *model.Instance
			// Dimension is the dimension argument value.
			Dimension *model.Dimension
		}
	}
}

// Insert calls InsertFunc.
func (mock *DimensionRepositoryMock) Insert(instance *model.Instance, dimension *model.Dimension) (*model.Dimension, error) {
	if mock.InsertFunc == nil {
		panic("moq: DimensionRepositoryMock.InsertFunc is nil but DimensionRepository.Insert was just called")
	}
	callInfo := struct {
		Instance  *model.Instance
		Dimension *model.Dimension
	}{
		Instance:  instance,
		Dimension: dimension,
	}
	lockDimensionRepositoryMockInsert.Lock()
	mock.calls.Insert = append(mock.calls.Insert, callInfo)
	lockDimensionRepositoryMockInsert.Unlock()
	return mock.InsertFunc(instance, dimension)
}

// InsertCalls gets all the calls that were made to Insert.
// Check the length with:
//     len(mockedDimensionRepository.InsertCalls())
func (mock *DimensionRepositoryMock) InsertCalls() []struct {
	Instance  *model.Instance
	Dimension *model.Dimension
} {
	var calls []struct {
		Instance  *model.Instance
		Dimension *model.Dimension
	}
	lockDimensionRepositoryMockInsert.RLock()
	calls = mock.calls.Insert
	lockDimensionRepositoryMockInsert.RUnlock()
	return calls
}
