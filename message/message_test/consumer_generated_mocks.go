// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package message_test

import (
	"github.com/ONSdigital/dp-dimension-importer/event"
	"github.com/ONSdigital/go-ns/kafka"
	"github.com/ONSdigital/go-ns/log"
	"sync"
)

var (
	lockKafkaMessageMockCommit  sync.RWMutex
	lockKafkaMessageMockGetData sync.RWMutex
)

// KafkaMessageMock is a mock implementation of KafkaMessage.
//
//     func TestSomethingThatUsesKafkaMessage(t *testing.T) {
//
//         // make and configure a mocked KafkaMessage
//         mockedKafkaMessage := &KafkaMessageMock{
//             CommitFunc: func()  {
// 	               panic("TODO: mock out the Commit method")
//             },
//             GetDataFunc: func() []byte {
// 	               panic("TODO: mock out the GetData method")
//             },
//         }
//
//         // TODO: use mockedKafkaMessage in code that requires KafkaMessage
//         //       and then make assertions.
//
//     }
type KafkaMessageMock struct {
	// CommitFunc mocks the Commit method.
	CommitFunc func()

	// GetDataFunc mocks the GetData method.
	GetDataFunc func() []byte

	// calls tracks calls to the methods.
	calls struct {
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// GetData holds details about calls to the GetData method.
		GetData []struct {
		}
	}
}

// Commit calls CommitFunc.
func (mock *KafkaMessageMock) Commit() {
	if mock.CommitFunc == nil {
		panic("moq: KafkaMessageMock.CommitFunc is nil but KafkaMessage.Commit was just called")
	}
	callInfo := struct {
	}{}
	lockKafkaMessageMockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	lockKafkaMessageMockCommit.Unlock()
	mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//     len(mockedKafkaMessage.CommitCalls())
func (mock *KafkaMessageMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	lockKafkaMessageMockCommit.RLock()
	calls = mock.calls.Commit
	lockKafkaMessageMockCommit.RUnlock()
	return calls
}

// GetData calls GetDataFunc.
func (mock *KafkaMessageMock) GetData() []byte {
	if mock.GetDataFunc == nil {
		panic("moq: KafkaMessageMock.GetDataFunc is nil but KafkaMessage.GetData was just called")
	}
	callInfo := struct {
	}{}
	lockKafkaMessageMockGetData.Lock()
	mock.calls.GetData = append(mock.calls.GetData, callInfo)
	lockKafkaMessageMockGetData.Unlock()
	return mock.GetDataFunc()
}

// GetDataCalls gets all the calls that were made to GetData.
// Check the length with:
//     len(mockedKafkaMessage.GetDataCalls())
func (mock *KafkaMessageMock) GetDataCalls() []struct {
} {
	var calls []struct {
	}
	lockKafkaMessageMockGetData.RLock()
	calls = mock.calls.GetData
	lockKafkaMessageMockGetData.RUnlock()
	return calls
}

var (
	lockKafkaConsumerMockIncoming sync.RWMutex
)

// KafkaConsumerMock is a mock implementation of KafkaConsumer.
//
//     func TestSomethingThatUsesKafkaConsumer(t *testing.T) {
//
//         // make and configure a mocked KafkaConsumer
//         mockedKafkaConsumer := &KafkaConsumerMock{
//             IncomingFunc: func() chan kafka.Message {
// 	               panic("TODO: mock out the Incoming method")
//             },
//         }
//
//         // TODO: use mockedKafkaConsumer in code that requires KafkaConsumer
//         //       and then make assertions.
//
//     }
type KafkaConsumerMock struct {
	// IncomingFunc mocks the Incoming method.
	IncomingFunc func() chan kafka.Message

	// calls tracks calls to the methods.
	calls struct {
		// Incoming holds details about calls to the Incoming method.
		Incoming []struct {
		}
	}
}

// Incoming calls IncomingFunc.
func (mock *KafkaConsumerMock) Incoming() chan kafka.Message {
	if mock.IncomingFunc == nil {
		panic("moq: KafkaConsumerMock.IncomingFunc is nil but KafkaConsumer.Incoming was just called")
	}
	callInfo := struct {
	}{}
	lockKafkaConsumerMockIncoming.Lock()
	mock.calls.Incoming = append(mock.calls.Incoming, callInfo)
	lockKafkaConsumerMockIncoming.Unlock()
	return mock.IncomingFunc()
}

// IncomingCalls gets all the calls that were made to Incoming.
// Check the length with:
//     len(mockedKafkaConsumer.IncomingCalls())
func (mock *KafkaConsumerMock) IncomingCalls() []struct {
} {
	var calls []struct {
	}
	lockKafkaConsumerMockIncoming.RLock()
	calls = mock.calls.Incoming
	lockKafkaConsumerMockIncoming.RUnlock()
	return calls
}

var (
	lockCompletedProducerMockCompleted sync.RWMutex
)

// CompletedProducerMock is a mock implementation of CompletedProducer.
//
//     func TestSomethingThatUsesCompletedProducer(t *testing.T) {
//
//         // make and configure a mocked CompletedProducer
//         mockedCompletedProducer := &CompletedProducerMock{
//             CompletedFunc: func(e event.InstanceCompletedEvent) error {
// 	               panic("TODO: mock out the Completed method")
//             },
//         }
//
//         // TODO: use mockedCompletedProducer in code that requires CompletedProducer
//         //       and then make assertions.
//
//     }
type CompletedProducerMock struct {
	// CompletedFunc mocks the Completed method.
	CompletedFunc func(e event.InstanceCompletedEvent) error

	// calls tracks calls to the methods.
	calls struct {
		// Completed holds details about calls to the Completed method.
		Completed []struct {
			// E is the e argument value.
			E event.InstanceCompletedEvent
		}
	}
}

// Completed calls CompletedFunc.
func (mock *CompletedProducerMock) Completed(e event.InstanceCompletedEvent) error {
	if mock.CompletedFunc == nil {
		panic("moq: CompletedProducerMock.CompletedFunc is nil but CompletedProducer.Completed was just called")
	}
	callInfo := struct {
		E event.InstanceCompletedEvent
	}{
		E: e,
	}
	lockCompletedProducerMockCompleted.Lock()
	mock.calls.Completed = append(mock.calls.Completed, callInfo)
	lockCompletedProducerMockCompleted.Unlock()
	return mock.CompletedFunc(e)
}

// CompletedCalls gets all the calls that were made to Completed.
// Check the length with:
//     len(mockedCompletedProducer.CompletedCalls())
func (mock *CompletedProducerMock) CompletedCalls() []struct {
	E event.InstanceCompletedEvent
} {
	var calls []struct {
		E event.InstanceCompletedEvent
	}
	lockCompletedProducerMockCompleted.RLock()
	calls = mock.calls.Completed
	lockCompletedProducerMockCompleted.RUnlock()
	return calls
}

var (
	lockErrorEventHandlerMockHandle sync.RWMutex
)

// ErrorEventHandlerMock is a mock implementation of ErrorEventHandler.
//
//     func TestSomethingThatUsesErrorEventHandler(t *testing.T) {
//
//         // make and configure a mocked ErrorEventHandler
//         mockedErrorEventHandler := &ErrorEventHandlerMock{
//             HandleFunc: func(instanceID string, err error, data log.Data)  {
// 	               panic("TODO: mock out the Handle method")
//             },
//         }
//
//         // TODO: use mockedErrorEventHandler in code that requires ErrorEventHandler
//         //       and then make assertions.
//
//     }
type ErrorEventHandlerMock struct {
	// HandleFunc mocks the Handle method.
	HandleFunc func(instanceID string, err error, data log.Data)

	// calls tracks calls to the methods.
	calls struct {
		// Handle holds details about calls to the Handle method.
		Handle []struct {
			// InstanceID is the instanceID argument value.
			InstanceID string
			// Err is the err argument value.
			Err error
			// Data is the data argument value.
			Data log.Data
		}
	}
}

// Handle calls HandleFunc.
func (mock *ErrorEventHandlerMock) Handle(instanceID string, err error, data log.Data) {
	if mock.HandleFunc == nil {
		panic("moq: ErrorEventHandlerMock.HandleFunc is nil but ErrorEventHandler.Handle was just called")
	}
	callInfo := struct {
		InstanceID string
		Err        error
		Data       log.Data
	}{
		InstanceID: instanceID,
		Err:        err,
		Data:       data,
	}
	lockErrorEventHandlerMockHandle.Lock()
	mock.calls.Handle = append(mock.calls.Handle, callInfo)
	lockErrorEventHandlerMockHandle.Unlock()
	mock.HandleFunc(instanceID, err, data)
}

// HandleCalls gets all the calls that were made to Handle.
// Check the length with:
//     len(mockedErrorEventHandler.HandleCalls())
func (mock *ErrorEventHandlerMock) HandleCalls() []struct {
	InstanceID string
	Err        error
	Data       log.Data
} {
	var calls []struct {
		InstanceID string
		Err        error
		Data       log.Data
	}
	lockErrorEventHandlerMockHandle.RLock()
	calls = mock.calls.Handle
	lockErrorEventHandlerMockHandle.RUnlock()
	return calls
}
